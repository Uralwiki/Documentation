<p>The following examples demonstrate some common practices for requesting Future Option data through universe filtering.</p>

<h4>Example 1: Call Spread</h4>
<p>The following example demonstrates how to implement a <a href="/docs/v2/writing-algorithms/trading-and-orders/option-strategies/bull-call-spread">bull call spread</a> option strategy using universe filtering. We have to first subscribe to the underlying Future (with filtering), then call <code class="csharp">AddFutureOption</code><code class="python">self.add_future_option</code> with the underlying <code>Symbol</code> and the filtering function. We use <code class="csharp">CallSpread</code><code class="python">call_spread</code> method in the <code>OptionFilterUniverse</code> object to return only the 2 best match call contracts that forms a bull call spread.</p>
<div class="section-example-container">
    <pre class="csharp">public class FutureOptionAlgorithm : QCAlgorithm
{
    private Future _underlying;

    public override void Initialize()
    {
        // Filter the underlying continuous Futures to narrow the FOP spectrum.
        _underlying = AddFuture(Futures.Indices.SP500EMini,
            extendedMarketHours: true,
            dataMappingMode: DataMappingMode.OpenInterest,
            dataNormalizationMode: DataNormalizationMode.BackwardsRatio,
            contractDepthOffset: 0);
        _underlying.SetFilter(0, 182);
        // Use CallSpread filter to obtain the 2 best-matched contracts that forms a call spread.
        // It simplifies from further filtering and reduce computation on redundant subscription.
        AddFutureOption(_underlying.Symbol, (u) =&gt; u.IncludeWeeklys().CallSpread(5, 5, -5));
    }
    
    public override void OnData(Slice slice)
    {
        // Create canonical symbol for the mapped future contract, since we need that to access the option chain.
        var symbol = QuantConnect.Symbol.CreateCanonicalOption(_underlying.Mapped);
    
        // Get option chain data for the mapped future only.
        if (!Portfolio.Invested && 
            slice.OptionChains.TryGetValue(symbol, out var chain))
        {
            // It requires 2 contracts with different strikes to form a call spread, so we make sure at least 2 contracts are present.
            if (chain.Count() &lt; 2)
            {
                return;
            }
    
            // Separate the contracts by strike, as we need to access their strike.
            var itmStrike = chain.Min(x =&gt; x.Strike);
            var otmStrike = chain.Max(x =&gt; x.Strike);
    
            // Use abstraction method to order a bull call spread to avoid manual error.
            var optionStrategy = OptionStrategies.BullCallSpread(symbol, itmStrike, otmStrike, chain.First().Expiry);
            Buy(optionStrategy, 1);
        }
    }
}</pre>
    <pre class="python">class FutureOptionAlgorithm(QCAlgorithm):
    def initialize(self) -&gt; None:
        # Filter the underlying continuous Futures to narrow the FOP spectrum.
        self.underlying = self.add_future(Futures.Indices.SP_500_E_MINI,
            extended_market_hours=True,
            data_mapping_mode=DataMappingMode.OPEN_INTEREST,
            data_normalization_mode=DataNormalizationMode.BACKWARDS_RATIO,
            contract_depth_offset=0)
        self.underlying.set_filter(0, 182)
        # Use CallSpread filter to obtain the 2 best-matched contracts that forms a call spread.
        # It simplifies from further filtering and reduce computation on redundant subscription.
        self.add_future_option(self.underlying.symbol, lambda u: u.include_weeklys().call_spread(5, 5, -5))
        
    def on_data(self, slice: Slice) -&gt; None:
        # Create canonical symbol for the mapped future contract, since we need that to access the option chain.
        symbol = Symbol.create_canonical_option(self.underlying.mapped)
    
        # Get option chain data for the mapped future only.
        chain = slice.option_chains.get(symbol)
        if not self.portfolio.invested and chain:
            # It requires 2 contracts with different strikes to form a call spread, so we make sure at least 2 contracts are present.
            if len(list(chain)) &lt; 2:
                return
            
            # Separate the contracts by strike, as we need to access their strike.
            sorted_by_strike = sorted([x.strike for x in chain])
            itm_strike = sorted_by_strike[0]
            otm_strike = sorted_by_strike[-1]
        
            # Use abstraction method to order a bull call spread to avoid manual error.
            option_strategy = OptionStrategies.bull_call_spread(symbol, itm_strike, otm_strike, otm_call.expiry)
            self.buy(option_strategy, 1)</pre>
</div>

<p>Note that since both the underlying Future and the Future Option are expiring on the same day and are cash-settling in most cases, Lean can exercise the Future Option into account cash automatically at expiry and we do not need to handle the option exercise/assignment event.</p>
