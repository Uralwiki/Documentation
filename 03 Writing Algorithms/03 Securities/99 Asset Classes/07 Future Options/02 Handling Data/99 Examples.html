<p>The following examples demonstrate some common practices for handling Future Option data.</p>

<h4>Example 1: Monthly Protective Put</h4>
<p>The following algorithm shows how to perform monthly selection on individual ES Future Option contract to implement a <a href="/docs/v2/writing-algorithms/trading-and-orders/option-strategies/protective-put">protective put</a> option strategy to hedge speculation on S&P500 Future. It is a useful tool to hedge the excessive risk on leverage using Futures to trade.</p>

<div class="section-example-container">
    <pre class="csharp">private Future _underlying;

public override void Initialize()
{
    // Subscribe to the underlying and filter, seed the last price
    SetSecurityInitializer((security) =&gt; new FuncSecuritySeeder(GetLastKnownPrices).SeedSecurity(security));
    _underlying = AddFuture(Futures.Indices.SP500EMini,
        dataMappingMode: DataMappingMode.OpenInterest,
        dataNormalizationMode: DataNormalizationMode.Raw,
        contractDepthOffset: 0);
    _underlying.SetFilter(0, 31);

    // Schedule a monthly event on selection of future-future option pair
    Schedule.On(
        DateRules.MonthStart(_underlying.Symbol),
        TimeRules.AfterMarketOpen(_underlying.Symbol, 0),
        SelectionAndRebalance
    );
}

private void SelectionAndRebalance()
{
    // Get all available put Future Option contracts
    var contractSymbols = OptionChainProvider.GetOptionContractList(_underlying.Mapped, Time)
        .Where(symbol =&gt; symbol.ID.OptionRight == OptionRight.Put)
        .ToList();
    // The max expiry of the front month future will expire the same time as the future
    var expiry = contractSymbols.Max(symbol =&gt; symbol.ID.Date);
    // Get ATM contract
    var selected = contractSymbols.Where(symbol =&gt; symbol.ID.Date == expiry)
        .OrderBy(symbol =&gt; Math.Abs(symbol.ID.StrikePrice - Securities[_underlying.Mapped].Price))
        .First();
    var contract = AddFutureOptionContract(selected);

    // Formulate the protective put strategy that both Future and Future Option expires at end of month
    MarketOrder(_underlying.Mapped, contract.SymbolProperties.ContractMultiplier);
    MarketOrder(contract.Symbol, 1);
}</pre>
    <pre class="python">def initialize(self) -&gt; None:
    # Subscribe to the underlying and filter, seed the last price
    self.set_security_initializer(lambda security: FuncSecuritySeeder(self.get_last_known_prices).seed_security(security))
    self.underlying = self.add_future(Futures.Indices.SP_500_E_MINI,
        data_mapping_mode=DataMappingMode.OPEN_INTEREST,
        data_normalization_mode=DataNormalizationMode.RAW,
        contract_depth_offset=0)
    self.underlying.set_filter(0, 31)

    # Schedule a monthly event on selection of future-future option pair
    self.schedule.on(
        self.date_rules.month_start(self.underlying.symbol),
        self.time_rules.after_market_open(self.underlying.symbol, 0),
        self.selection_and_rebalance
    )

def selection_and_rebalance(self) -&gt; None:
    # Get all available Future Option contracts
    contract_symbols = self.option_chain_provider.get_option_contract_list(self.underlying.mapped, self.time)
    # Puts only
    contract_symbols = [symbol for symbol in contract_symbols if symbol.id.option_right == OptionRight.PUT]
    # The max expiry of the front month future will expire the same time as the future
    expiry = max(symbol.id.date for symbol in contract_symbols)
    filtered_symbols = [symbol for symbol in contract_symbols if symbol.id.date == expiry]
    # Get ATM contract
    selected = sorted(filtered_symbols, key=lambda symbol: abs(symbol.id.strike_price - self.securities[self.underlying.mapped].price))[0]
    contract = self.add_future_option_contract(selected)

    # Formulate the protective put strategy that both Future and Future Option expires at end of month
    self.market_order(self.underlying.mapped, contract.symbol_properties.contract_multiplier)
    self.market_order(contract.symbol, 1)</pre>
</div>

<h4>Example 2: Weekly Covered Call</h4>
<p>The below example demonstrates a weekly-renewing <a href="/docs/v2/writing-algorithms/trading-and-orders/option-strategies/covered-call">covered call</a> strategy to collect credit of selling the option. It filters the ATM call contract that expires within the current week at week start using <code class="csharp">SetFilter</code><code class="python">set_filter</code> filtering function.</p>
<div class="section-example-container">
    <pre class="csharp">private Future _underlying;

public override void Initialize()
{
    // Subscribe to the underlying and filter
    _underlying = AddFuture(Futures.Indices.SP500EMini,
        extendedMarketHours: true,
        dataMappingMode: DataMappingMode.OpenInterest,
        dataNormalizationMode: DataNormalizationMode.BackwardsRatio,
        contractDepthOffset: 0);
    _underlying.SetFilter(0, 182);
    // Subscribe to future option with option universe filter
    // We try to get the call contracts that expire at the current week
    AddFutureOption(_underlying.Symbol, (u) =&gt; u.IncludeWeeklys().CallsOnly().Expiration(0, 5));
}

public override void OnData(Slice slice)
{
    // Create canonical symbol for the mapped future contract
    var symbol = QuantConnect.Symbol.CreateCanonicalOption(_underlying.Mapped);

    // Get option chain data for the mapped future
    if (!Portfolio.Invested && 
        slice.OptionChains.TryGetValue(symbol, out var chain))
    {
        // Obtain the ATM call that expires at the end of week
        var expiry = chain.Max(x =&gt; x.Expiry);
        var atmCall = chain.Where(x =&gt; x.Expiry == expiry)
            .OrderBy(x =&gt; Math.Abs(x.Strike - x.UnderlyingLastPrice))
            .First();

        // Set up option strategy to buy the cover call
        var optionStrategy = OptionStrategies.CoveredCall(symbol, atmCall.Strike, expiry);
        Buy(optionStrategy, 1);
    }
}</pre>
    <pre class="python">def initialize(self) -&gt; None:
    # Subscribe to the underlying and filter
    self.underlying = self.add_future(Futures.Indices.SP_500_E_MINI,
        extended_market_hours=True,
        data_mapping_mode=DataMappingMode.OPEN_INTEREST,
        data_normalization_mode=DataNormalizationMode.BACKWARDS_RATIO,
        contract_depth_offset=0)
    self.underlying.set_filter(0, 182)
    # Subscribe to future option with option universe filter
    self.add_future_option(self.underlying.symbol, lambda u: u.include_weeklys().calls_only().expiration(0, 5))

def on_data(self, slice: Slice) -&gt; None:
    # Create canonical symbol for the mapped future contract
    symbol = Symbol.create_canonical_option(self.underlying.mapped)

    # Get option chain data for the mapped future
    chain = slice.option_chains.get(symbol)
    if not self.portfolio.invested and chain:
        # Obtain the ATM call that expires at the end of week
        expiry = max(x.id.date for x in chain)
        atm_call = sorted([x for x in chain if x.id.date == expiry],
            key=lambda x: abs(x.strike - x.underlying_last_price))[0]

        # Set up option strategy to buy the cover call
        option_strategy = OptionStrategies.covered_call(symbol, atm_call.strike,expiry)
        self.buy(option_strategy, 1)</pre>
</div>

<p>Note that since both the underlying Future and the Future Option are expiring on the same day and are cash-settling in most cases, Lean can exercise the Future Option into account cash automatically at expiry and we do not need to handle the option exercise/assignment event.</p>