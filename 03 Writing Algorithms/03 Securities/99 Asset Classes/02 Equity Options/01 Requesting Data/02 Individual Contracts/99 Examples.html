<h4>Example 1: Covered Call</h4>
<p>A cover call consists of a short call and with a lot of the underlying equity. Although it capped the maximum profit if the underlying skyrocketted, it also provide extra credit received while speculating the underlying will rise.</p>
<div class="section-example-container">
    <pre class="csharp">private Symbol _aapl;
private Option _option;

public override void Initialize()
{
    // Subscribe to AAPL (underlying)
    _aapl = AddEquity("AAPL").Symbol;
    // Subscribe to AAPL's option
    _option = AddOption(_aapl);
    // Select the calls that is 2 strikes away from current price within 30 days expiry
    _option.SetFilter((u) =&gt; u.CallsOnly().Strikes(-2, 2).Expiration(0, 30));
}

public override void OnData(Slice slice)
{
    // Get option chain of AAPL
    if (!Portfolio.Invested &&
        slice.OptionChains.TryGetValue(_option.Symbol, out var chain))
    {
        // Get the contract closest to ATM and expiry
        var contract = chain.OrderBy(x =&gt; x.Expiry)
            .ThenBy(x =&gt; Math.Abs(x.Strike - x.UnderlyingLastPrice))
            .First();

        // Short 1 option contract
        MarketOrder(contract.Symbol, -1);
        // Order 1 lot of underlying
        MarketOrder(_aapl, _option.SymbolProperties.ContractMultiplier);
    }
}

public override void OnOrderEvent(OrderEvent orderEvent)
{
    // Exit AAPL if the short call is not exercised
    // If it is exercised, the underlying will be used to settle the contract automatically
    if (orderEvent.Ticket.OrderType == OrderType.OptionExercise &&
        !orderEvent.IsInTheMoney)
    {
        MarketOrder(_aapl, -_option.SymbolProperties.ContractMultiplier);
    }
}</pre>
    <pre class="python">def initialize(self) -&gt; None:
    # Subscribe to AAPL (underlying)
    self.aapl = self.add_equity("AAPL").symbol
    # Subscribe to AAPL's option
    self.option = self.add_option(self.aapl)
    # Select the calls that is 2 strikes away from current price within 30 days expiry
    self.option.set_filter(lambda u: u.calls_only().strikes(-2, 2).expiration(0, 30))

def on_data(self, slice: Slice) -&gt; None:
    # Get option chain of AAPL
    chain = slice.option_chains.get(self.option.symbol)
    if self.portfolio.invested or not chain:
        return
    
    # Get the contract closest to ATM and expiry
    expiry = min(x.expiry for x in chain)
    contracts = sorted([x for x in chain if x.expiry == expiry],
                       key=lambda x: abs(x.strike - x.underlying_last_price))[0]
        
    # Short 1 option contract
    self.market_order(contract.symbol, -1)
    # Order 1 lot of underlying
    self.market_order(self.aapl, self.option.symbol_properties.contract_multipliers)

def on_order_event(self, order_event: OrderEvent) -&gt; None:
    # Exit AAPL if the short call is not exercised
    # If it is exercised, the underlying will be used to settle the contract automatically
    if order_event.ticket.order_type == OrderType.OPTION_EXERCISE \
    and not order_event.is_in_the_money:
        self.market_order(self.aapl, -self.option.symbol_properties.contract_multipliers)</pre>
</div>

<h4>Example 2: 0-DTE Bull Put Spread</h4>
<p>0DTE options often trades with high volume and volatility, providing arbitration opportunities and higher profit margin on spread type trading. In this example, we make use of 0-DTE SPY options to trade <a href="/docs/v2/writing-algorithms/trading-and-orders/option-strategies/bull-put-spread">bull put spread</a> option strategy.</p>
<div class="section-example-container">
    <pre class="csharp">private Option _option;

public override void Initialize()
{
    // Subscribe to SPY options
    _option = AddOption("SPY");
    // Select the 0-DTE puts that are 5 strikes away from current price and be able to form a put spread
    _option.SetFilter((u) =&gt; u.IncludeWeeklys().Expiration(0, 0).PutSpread(0, 5));

    // Exit all positions before market close
    Schedule.On(
        DateRules.EveryDay(_option.Symbol),
        TimeRules.BeforeMarketClose(_option.Symbol, 1),
        ExitPositions
    );
}

public override void OnData(Slice slice)
{
    // Get option chain of SPY
    if (!Portfolio.Invested && Time.Hour &lt; 15 &&
        slice.OptionChains.TryGetValue(_option.Symbol, out var chain))
    {
        // Obtain the ITM strike, OTM strike and expiry to form the bull put spread
        var itmStrike = chain.Max(x =&gt; x.Strike);
        var otmStrike = chain.Min(x =&gt; x.Strike);
        var expiry = chain.Min(x =&gt; x.Expiry);

        // Form a bull put spread strategy and order
        var bullPutSpread = OptionStrategies.BullPutSpread(_option.Symbol, itmStrike, otmStrike, expiry);
        Buy(bullPutSpread, 1);
    }
}

private void ExitPositions()
{
    // Exit all positions
    Liquidate();
}</pre>
    <pre class="python">def initialize(self) -&gt; None:
    # Subscribe to SPY option
    self.option = self.add_option("SPY")
    # Select the 0-DTE puts that are 5 strikes away from current price and be able to form a put 
    self.option.set_filter(lambda u: u.include_weeklys().expiration(0, 0).put_spread(0, 5))

    # Exit all positions before market close
    self.schedule.on(
        self.date_rules.every_day(self.option.symbol),
        self.time_rules.before_market_close(self.option.symbol, 1),
        self.exit_position
    );

def on_data(self, slice: Slice) -&gt; None:
    # Get option chain of AAPL
    chain = slice.option_chains.get(self.option.symbol)
    if self.portfolio.invested or self.time.hour >= 15 or not chain:
        return
    
    # Obtain the ITM strike, OTM strike and expiry to form the bull put spread
    expiry = min(x.expiry for x in chain)
    itm_strike = max(x.strike for x in chain)
    otm_strike = min(x.strike for x in chain)
        
    # Form a bull put spread strategy and order
    bull_put_spread = OptionStrategies.bull_put_spread(self.option.symbol, itm_strike, otm_strike, expiry)
    self.buy(bull_put_spread, 1)

def exit_position(self) -&gt; None:
    self.liquidate()</pre>
</div>

<h4>Example 3: Filter Option Contracts By Option Greeks indicator</h4>
<p>In this example, we demonstrate filtering option contracts by <a href="/docs/v2/writing-algorithms/indicators/supported-indicators/delta">Delta</a>, an Option Greeks indicator. We filter all the call contracts with <code>Delta</code> greater than 0.99 that expires just more than 7 days later on Monday morning. This filter is useful when creating a hedge replicate portfolio for arbitration.</p>
<div class="section-example-container">
    <pre class="csharp">private Symbol _spy;
private DividendYieldProvider _dividendYieldModel;
private List&lt;Symbol&gt; _universe = new();

public override void Initialize()
{
    // Subscribe to SPY
    _spy = AddEquity("SPY", dataNormalizationMode: DataNormalizationMode.Raw).Symbol;
    // Instantiate dividend yield model
    _dividendYieldModel = new DividendYieldProvider(_spy);

    // Schedule a filtering on Monday morning every week
    Schedule.On(
        DateRules.Every(DayOfWeek.Monday),
        TimeRules.At(7, 30),
        Filter
    );
}

private void Filter()
{
    // Get all option contracts trading
    var contractSymbols = OptionChainProvider.GetOptionContractList(_spy, Time);
    // Get the first expiry that just over 7 days later and within 1 year
    var expiry = contractSymbols.Where(x =&gt; x.ID.Date &gt;= Time.AddDays(7))
        .Min(x =&gt; x.ID.Date);
    // Get contracts expires on the selected expiry
    var filtered = contractSymbols.Where(x =&gt; x.ID.Date == expiry).ToList();

    // Iterate each strike price and obtain the delta
    var symbolDelta = new Dictionary&lt;Symbol, decimal&gt;();
    foreach (var strike in filtered.Select(x =&gt; x.ID.StrikePrice).Distinct())
    {
        // Obtain the call and put of the strike
        var call = filtered.SingleOrDefault(x =&gt; 
            x.ID.StrikePrice == strike && x.ID.OptionRight == OptionRight.Call);
        var put = filtered.SingleOrDefault(x =&gt; 
            x.ID.StrikePrice == strike && x.ID.OptionRight == OptionRight.Put);
        if (call == null || put == null) continue;

        // Get the delta for the call and save
        var delta = GetDelta(call, put);
        symbolDelta.Add(call, delta);
    }

    // Update the filtered list of contract symbols, subscribe to the contract data
    _universe = symbolDelta.Where(kvp =&gt; kvp.Value &gt;= 0.99m)
        .Select(x =&gt; AddOptionContract(x.Key).Symbol)
        .ToList();
}

private decimal GetDelta(Symbol call, Symbol put)
{
    // Create a new Delta indicator
    var delta = new Delta(call, RiskFreeInterestRateModel, _dividendYieldModel, put, OptionPricingModelType.ForwardTree);

    // Warm up the indicator using both mirror contract pairs and the underlying
    var history = History&lt;QuoteBar&gt;(new[] { call, put, _spy }, 1, Resolution.Daily);
    foreach (var bar in history)
    {
        delta.Update(new IndicatorDataPoint(call, bar[call].EndTime, bar[call].Close));
        delta.Update(new IndicatorDataPoint(put, bar[put].EndTime, bar[put].Close));
        delta.Update(new IndicatorDataPoint(_spy, bar[_spy].EndTime, bar[_spy].Close));
    }

    // Return the latest delta value
    return delta.Current.Value;
}</pre>
    <pre class="python">def initialize(self) -&gt; None:
    self.universe = []
    # Subscribe to SPY
    self.spy = self.add_equity("SPY", data_normalization_mode=DataNormalizationMode.RAW).symbol
    # Instantiate dividend yield model
    self.dividend_yield_provider = DividendYieldProvider(self.spy)

    # Schedule a filtering on Monday morning every week
    self.schedule.on(
        self.date_rules.every(DayOfWeek.MONDAY),
        self.time_rules.at(7, 30),
        self.filter
    )

def filter(self) -&gt; None:
    # Get all option contracts trading
    contract_symbols = self.option_chain_provider.get_option_contract_list(self.spy, self.time)
    # Get the first expiry that just over 7 days later and within 1 year
    expiry = min(x.id.date for x in contract_symbols if x.id.date &gt;= self.time + timedelta(7))
    # Get contracts expires on the selected expiry
    filtered = [x for x in contract_symbols if x.id.date == expiry]

    # Iterate each strike price and obtain the delta
    symbol_delta = {}
    for strike in set(x.id.strike_price for x in filtered):
        # Obtain the call and put of the strike
        call = next(filter(lambda x: x.id.option_right == OptionRight.CALL and x.id.strike_price == strike, filtered), None)
        put = next(filter(lambda x: x.id.option_right == OptionRight.PUT and x.id.strike_price == strike, filtered), None)
        if not call or not put:
            continue
        
        # Get the delta for the call and save
        delta = self.get_delta(call, put)
        symbol_delta[call] = delta
    
    # Update the filtered list of contract symbols, subscribe to the contract data
    self.universe = [self.add_option_contract(call).symbol 
        for call, delta in symbol_delta if delta &gt;= 0.99]
    
def get_delta(self, call: Symbol, put: Symbol) -&gt; float:
    # Create a new Delta indicator
    delta = Delta(call, self.risk_free_interest_rate_model, self.dividend_yield_provider, put, OptionPricingModelType.FORWARD_TREE)

    # Warm up the indicator using both mirror contract pairs and the underlying
    history = self.history[QuoteBar]([call, put, self.spy], 1, Resolution.DAILY)
    for bar in history:
        delta.update(IndicatorDataPoint(call, bar[call].end_time, bar[call].close))
        delta.update(IndicatorDataPoint(put, bar[put].end_time, bar[put].close))
        delta.update(IndicatorDataPoint(self.spy, bar[self.spy].end_time, bar[self.spy].close))
    
    # Return the latest delta value
    return delta.current.value</pre>
</div>

<h4>Example 4: Wheel Strategy</h4>
<p>The Wheel strategy is a popular trading strategy for Options that enables traders to build a steady flow of income from Equity assets they want to hold for the long term.</p>
<div class="section-example-container">
    <pre class="csharp">private Symbol _spy;
private decimal _otmThreshold = 0.05m;

public override void Initialize()
{
    // Subscribe to SPY
    _spy = AddEquity("SPY", dataNormalizationMode: DataNormalizationMode.Raw).Symbol;
}

public override void OnData(Slice slice)
{
    // Open position if nothing is invested
    if (!Portfolio.Invested && slice.Bars.ContainsKey(_spy))
    {
        // Get the target put contract
        var symbol = GetTargetContract(OptionRight.Put, slice.Bars[_spy].Price * (1 - _otmThreshold));
        // Short the put contract
        SetHoldings(symbol, -0.2m);
    }
    // Exit position if the put option is being assigned
    else if (Portfolio[_spy].Invested && slice.Bars.ContainsKey(_spy))
    {
        // Get the target call contract
        var symbol = GetTargetContract(OptionRight.Put, slice.Bars[_spy].Price * (1 + _otmThreshold));
        // Short the corresponding number of call contracts
        MarketOrder(symbol, -Portfolio[_spy].Quantity / Securities[_spy].SymbolProperties.ContractMultiplier);
    }
}

private Symbol GetTargetContract(OptionRight right, decimal targetPrice)
{
    // Get all option contracts available
    var contractSymbols = OptionChainProvider.GetOptionContractList(_spy, Time).ToList();
    // Get the first expiry after 30 days
    var expiry = contractSymbols.Min(x =&gt; x.ID.Date);
    // Filter for OTM contracts that meet the expiry and option right requirement, then order by strike price
    var filtered = contractSymbols.Where(x =&gt;
            x.ID.Date == expiry &&
            x.ID.OptionRight == right &&
            (right == OptionRight.Call ? x.ID.StrikePrice &gt;= targetPrice : x.ID.StrikePrice &lt;= targetPrice)
        )
        .OrderBy(x =&gt; x.ID.StrikePrice)
        .ToList();
    // Return the most ITM contract
    var selected = right == OptionRight.Call ? filtered.First() : filtered.Last();
    return AddOptionContract(selected).Symbol;
}</pre>
    <pre class="python">def initialize(self) -&gt; None:
    # Subscribe to SPY
    self.spy = self.add_equity("SPY", data_normalization_mode=DataNormalizationMode.RAW).symbol
    # Set OTM threshold
    self.otm_threshold = 0.05

def on_data(self, slice: Slice) -&gt; None:
    # Open position if nothing is invested
    if not self.portfolio.invested and self.spy in slice.bars:
        # Get the target put contract
        symbol = self.get_target_contract(OptionRight.PUT, slice.bars[self.spy].price * (1 - self.otm_threshold))
        # Short the put contract
        self.set_holdings(symbol, -0.2)
    # Exit position if the put option is being assigned
    elif self.portfolio[self.spy].invested and self.spy in slice.bars:
        # Get the target call contract
        symbol = self.get_target_contract(OptionRight.CALL, slice.bars[self.spy].price * (1 + self.otm_threshold))
        # Short the corresponding number of call contracts
        self.market_order(symbol, self.portfolio[self.spy].quantity / self.securities[self.spy].symbol_properties.contract_multipliers)
    
def get_target_contract(self, right: OptionRight, target_price: float) -&gt; Symbol:
    # Get all option contracts available
    contract_symbols = self.option_chain_provider.get_option_contract_list(self.spy, self.time)
    # Get the first expiry after 30 days
    expiry = min(x.id.date for x in contract_symbols)
    # Filter for OTM contracts that meet the expiry and option right requirement
    filtered = [x for x in contract_symbols \
        if x.id.date == expiry \
        and x.id.option_right == right \
        and (x.id.strike_price &gt;= target_price if right == OptionRight.CALL else x.id.strike_price &lt;= target_price)]
    # Order by strike price
    sorted_by_strikes = sorted(filtered, key=lambda x: x.id.strike_price)
    # Return the most ITM contract
    selected = sorted_by_strikes[0] if right == OptionRight.CALL else sorted_by_strikes[-1]
    return self.add_option_contract(selected).symbol</pre>
</div>
<p>For more details, refer to the <a href="https://www.quantconnect.com/research/17871/automating-the-wheel-strategy/p1">Wheel Strategy research post</a>.</p>

<h4>Example 5: Scan and Update Option Chain Every 5 Minutes</h4>
<p>
    The following example shows how to update the Option chain every five minutes. The <code>OptionChainManager</code> class implements the selection logic and manages the contract subscriptions.
</p>

<div class="section-example-container">
    <pre class="csharp">namespace QuantConnect.Algorithm.CSharp
{
    public class OptionChainProviderFullExample : QCAlgorithm
    {
        private Dictionary&lt;Symbol, OptionChainManager&gt; _chainManager = new();
        public override void Initialize()
        {
            SetStartDate(2023, 1, 2);
            SetEndDate(2023, 1, 30);
            SetCash(100000);
            UniverseSettings.Asynchronous = true;
            UniverseSettings.MinimumTimeInUniverse = TimeSpan.Zero;
            SetSecurityInitializer(new BrokerageModelSecurityInitializer(BrokerageModel, new FuncSecuritySeeder(GetLastKnownPrices)));
            var spy = AddEquity("SPY", dataNormalizationMode: DataNormalizationMode.Raw).Symbol;
            _chainManager[QuantConnect.Symbol.CreateCanonicalOption(spy)] = new(-10, 10, 0, 7);
            PopulateOptionChain();
            Schedule.On(DateRules.EveryDay(spy), TimeRules.AfterMarketOpen(spy, 1), PopulateOptionChain);
            Schedule.On(DateRules.EveryDay(spy), TimeRules.Every(TimeSpan.FromMinutes(5)), Filter);
        }
        
        private void PopulateOptionChain()
        {
            // The contract list is updated daily, so we can get it and apply
            // the expiration filter as soon as the market open
            foreach (var (symbol, manager) in _chainManager)
            {
                manager.SetChain(OptionChainProvider.GetOptionContractList(symbol, Time), Time);
            }
    
            Filter();
        }
        
        private void Filter()
        {
            foreach (var (symbol, manager) in _chainManager)
            {
                manager.Select(this, symbol);
            }
        }
        
        public override void OnData(Slice slice)
        {
            foreach (var (symbol, manager) in _chainManager)
            {
                if (!slice.OptionChains.TryGetValue(symbol, out var chain))
                    continue;
                var expiry = chain.Min(x =&gt; x.Expiry);
                var atmCall = chain
                    .Where(x =&gt; x.Expiry == expiry && x.Right == OptionRight.Call && Securities[x.Symbol].IsTradable)
                    .OrderBy(x =&gt; Math.Abs(chain.Underlying.Price - x.Strike))
                    .FirstOrDefault();

                if (atmCall != null && !Portfolio[atmCall.Symbol].Invested)
                    MarketOrder(atmCall.Symbol, 1);
            }
        }
    }

    internal class OptionChainManager
    {
        private readonly int _minStrike;
        private readonly int _maxStrike;
        private readonly int _minExpiry;
        private readonly int _maxExpiry;
        private List&lt;Symbol&gt; _chain = new();
        private readonly List&lt;Symbol&gt; _symbols = new();

        public OptionChainManager(int minStrike, int maxStrike, int minExpiry, int maxExpiry)
        {
            _minStrike = minStrike;
            _maxStrike = maxStrike;
            _minExpiry = minExpiry;
            _maxExpiry = maxExpiry;
        }

        public void SetChain(IEnumerable&lt;Symbol&gt; symbols, DateTime time)
        {
            _chain = symbols.Where(x =&gt;
            {
                var totalDays = (x.ID.Date - time).TotalDays;
                return _minExpiry &lt;= totalDays && totalDays &lt;= _maxExpiry;
            }).ToList();
        }
        
        public void Select(QCAlgorithm algorithm, Symbol underlyingSymbol)
        {
            if (_chain.IsNullOrEmpty())
                return;
            if (underlyingSymbol.IsCanonical())
                underlyingSymbol = underlyingSymbol.Underlying;

            var strikes = _chain.Select(x =&gt; x.ID.StrikePrice).OrderBy(x =&gt; x).Distinct().ToList();
            var spot = algorithm.Securities[underlyingSymbol].Price;
            var atm = strikes.OrderBy(x =&gt; Math.Abs(spot - x)).FirstOrDefault();
            var index = strikes.IndexOf(atm);
            var minStrike = strikes[Math.Max(0, index + _minStrike)];
            var maxStrike = strikes[Math.Min(strikes.Count - 1, index + _maxStrike)];
            var symbols = _chain.Where(x =&gt; minStrike &lt;= x.ID.StrikePrice && x.ID.StrikePrice &lt;= maxStrike).ToList();

            var toRemove = _symbols.Except(symbols).ToList();
            foreach (var symbol in toRemove)
            {
                if (algorithm.RemoveOptionContract(symbol))
                    _symbols.Remove(symbol);
            }
            var toAdd = symbols.Except(_symbols).ToList();
            foreach (var symbol in toAdd)
            {
                _symbols.Add(symbol);
                algorithm.AddOptionContract(symbol);
            }
        }
    }
}</pre>
    <pre class="python">class OptionChainProviderFullExample(QCAlgorithm):

    def initialize(self):
        self.set_start_date(2023, 1, 2)
        self.set_end_date(2023, 1, 30)
        self.set_cash(100000)
        self.universe_settings.asynchronous = True
        self.universe_settings.minimum_time_in_universe = timedelta(minutes=0)
        self.set_security_initializer(BrokerageModelSecurityInitializer(self.brokerage_model, FuncSecuritySeeder(self.get_last_known_prices)))
        spy = self.add_equity("SPY", data_normalization_mode=DataNormalizationMode.RAW).symbol
        self._chain_manager = {
            Symbol.create_canonical_option(spy): OptionChainManager(-10, 10, 0, 7)
        }
        self._populate_option_chain()
        self.schedule.on(self.date_rules.every_day(spy), self.time_rules.after_market_open(spy, 1), self._populate_option_chain)
        self.schedule.on(self.date_rules.every_day(spy), self.time_rules.every(timedelta(minutes=5)), self._filter)

    def _populate_option_chain(self):
        # The contract list is updated daily, so we can get it and apply
        # the expiration filter as soon as the market open
        for symbol, manager in self._chain_manager.items():
            manager.set_chain(self.option_chain_provider.get_option_contract_list(symbol, self.time), self.time)
        self._filter()

    def _filter(self):
        for symbol, manager in self._chain_manager.items():
            manager.select(self, symbol)

    def on_data(self, slice: Slice) -&gt; None:
        for symbol, _ in self._chain_manager.items():
            chain = slice.option_chains.get(symbol)
            if not chain: continue
            if self.portfolio[symbol.underlying].invested:
                self.liquidate(symbol.underlying)

            expiry = min([x.expiry for x in chain])
            contracts = [x for x in chain if x.expiry == expiry and x.right == OptionRight.CALL and self.securities[x.symbol].is_tradable]
            if not contracts: continue
            atm_call = sorted(contracts, key=lambda x: abs(chain.underlying.price-x.strike))[0]

            if not self.portfolio[atm_call.symbol].invested:
                self.market_order(atm_call.symbol, 1)

class OptionChainManager:
    _chain = []
    _symbols = []
    
    def __init__(self, min_strike, max_strike, min_expiry, max_expiry):
        self._min_strike = min_strike
        self._max_strike = max_strike
        self._min_expiry = min_expiry
        self._max_expiry = max_expiry
    
    def set_chain(self, symbols: List[Symbol], time: datetime) -&gt; None:
        self._chain = [x for x in symbols if self._min_expiry &lt;= (x.id.date - time).days &lt;= self._max_expiry]
    
    def select(self, algorithm: QCAlgorithm, symbol: Symbol) -&gt; None:
        if not self._chain:
            return
        if symbol.is_canonical():
            symbol = symbol.underlying
        strikes = sorted(set(x.id.strike_price for x in self._chain))
        spot = algorithm.securities[symbol].price
        atm = sorted(strikes, key=lambda x: abs(spot-x))[0]
        index = strikes.index(atm)
        min_strike = strikes[max(0, index + self._min_strike)]
        max_strike = strikes[min(len(strikes) - 1, index + self._max_strike)]
        symbols = set(x for x in self._chain if min_strike &lt;= x.id.strike_price &lt;= max_strike)
        to_remove = set(self._symbols).difference(symbols)
        for symbol in to_remove:
            if algorithm.remove_option_contract(symbol):
                self._symbols.remove(symbol)
        to_add = symbols.difference(self._symbols)
        for symbol in to_add:
            self._symbols.append(symbol)
            algorithm.add_option_contract(symbol)</pre>
</div>
