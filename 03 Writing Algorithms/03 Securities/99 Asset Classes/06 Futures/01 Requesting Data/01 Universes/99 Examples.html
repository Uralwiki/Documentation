<p>The following examples demonstrate some common practices for requesting Futures universe data.</p>

<h4>Example 1: Rollover</h4>
<p>Future contracts expire monthly or quarterly in most cases. Hence, if we hold Future position in month or quarter end, we must consider rolling over to the mapped contract. The following algorithm shows how to buy and roll over to the next front month Future contract. We make use of the universe selection filter to select the front month contract and order the next mapped contract during the previous one expires.</p>
<div class="section-example-container">
    <pre class="csharp">private Symbol _future;

public override void Initialize()
{
    // Add subscription of ES Futures
    var future = AddFuture(Futures.Indices.SP500EMini, extendedMarketHours: true);
    _future = future.Symbol;
    // Filter the universe to front month contract
    future.SetFilter((u) =&gt; u.OnlyApplyFilterAtMarketOpen().FrontMonth());
}

public override void OnSecuritiesChanged(SecurityChanges changes)
{
    // Liquidate if expired and exit universe
    foreach (var removed in changes.RemovedSecurities)
    {
        Liquidate(removed.Symbol);
    }
    
    // Roll position to newly mapped contract
    foreach (var added in changes.AddedSecurities)
    {
        if (!added.Symbol.IsCanonical())
        {
            LimitOrder(added.Symbol, 1m, Securities[_future].Price);
        }
    }
}</pre>
    <pre class="python">def initialize(self) -&gt; None:
    # Add subscription of ES Futures
    future = self.add_future(Futures.Indices.SP_500_E_MINI, extended_market_hours=True)
    self._future = future.symbol
    # Filter the universe to front month contract
    future.set_filter(lambda u: u.only_apply_filter_at_market_open().front_month())

def on_securities_changed(self, changes: SecurityChanges) -&gt; None:
    # Liquidate if expired and exit universe
    for removed in changes.removed_securities:
        self.liquidate(removed.symbol)
    
    # Roll position to newly mapped contract
    for added in changes.added_securities:
        if not added.symbol.is_canonical():
            self.limit_order(added.symbol, 1, self.securities[self._future].price)</pre>
</div>

<h4>Example 2: Continuous Future Indicator</h4>
<p>One of the major applications of <a href='/docs/v2/writing-algorithms/universes/futures#12-Continous-Contracts'>Continuous Future</a> is to obtain smooth price series to feed into indicators. This can ensure the indicator gets the correct price data that is comparable to the current mapped Future contract. In this example, we demonstrate a 252-day <a href="/docs/v2/writing-algorithms/indicators/supported-indicators/exponential-moving-average">Exponential Moving Average indicator</a> update using continuous ES contract data.</p>
<div class="section-example-container">
    <pre class="csharp">private dynamic _future;

public override void Initialize()
{
    // Add subscription of ES Futures with backward ratio normalization for continuous contract
    _future = AddFuture(Futures.Indices.SP500EMini,
        dataNormalizationMode: DataNormalizationMode.BackwardsRatio,
        extendedMarketHours: true);
    // Filter the universe to front month contract
    (_future as Future).SetFilter((u) =&gt; u.OnlyApplyFilterAtMarketOpen().FrontMonth());
    // Create 252-day EMA indicator
    _future.ema = EMA(_future.Symbol, 252, Resolution.Daily);
    // Warm up indicator
    WarmUpIndicator((Symbol)_future.Symbol, (ExponentialMovingAverage)_future.ema);
}

public override void OnData(Slice slice)
{
    if (!slice.Bars.ContainsKey(_future.Symbol))
    {
        return;
    }

    // Long the mapped contract if the current price above EMA
    if (_future.ema.Current.Value &gt;= slice.Bars[_future.Symbol].Close)
    {
        SetHoldings(_future.Mapped, 0.1m);
    }
    // Short otherwise
    else
    {
        SetHoldings(_future.Mapped, -0.1m);
    }
}

public override void OnSecuritiesChanged(SecurityChanges changes)
{
    // Liquidate if expired and exit universe
    foreach (var removed in changes.RemovedSecurities)
    {
        Liquidate(removed.Symbol);
    }
}</pre>
    <pre class="python">def initialize(self) -&gt; None:
    # Add subscription of ES Futures
    self._future = self.add_future(Futures.Indices.SP_500_E_MINI,
        data_normalization_mode=DataNormalizationMode.BACKWARDS_RATIO,
        extended_market_hours=True)
    # Filter the universe to front month contract
    self._future.set_filter(lambda u: u.only_apply_filter_at_market_open().front_month())
    # Create 252-day EMA indicator
    self._future.ema = self.ema(self._future.symbol, 252, Resolution.DAILY)
    # Warm up indicator
    self.warm_up_indicator(self._future.symbol, self._future.ema)

def on_data(self, slice: Slice) -&gt; None:
    if not self._future.symbol in slice.bars:
        return

    # Long the mapped contract if the current price above EMA
    if self._future.ema.current.value &gt;= slice.bars[self._future.symbol].close:
        self.set_holdings(self._future.mapped, 0.1)
    # Short otherwise
    else:
        self.set_holdings(self._future.mapped, -0.1)

def on_securities_changed(self, changes: SecurityChanges) -&gt; None:
    # Liquidate if expired and exit universe
    for removed in changes.removed_securities:
        self.liquidate(removed.symbol)</pre>
</div>

<h4>Example 3: Contango</h4>
<p>In Future trading, contango refers to the far-to-expiry Future contract price is higher than the spot price due to various reasons, such as storage fee and insurance of the commodities. The following example shows a contango trading by shorting the far contract that the price is above a threshold compared to the front month contract price and buying the front month contract to earn the premium in between.</p>
<div class="section-example-container">
    <pre class="csharp">private Symbol _future;

public override void Initialize()
{
    // Add subscription of micro gold Futures
    var future = AddFuture(Futures.Metals.MicroGold, extendedMarketHours: true);
    _future = future.Symbol;
    // Filter the universe to contracts expires within 3 months
    future.SetFilter((u) =&gt; u.OnlyApplyFilterAtMarketOpen().Expiration(0, 95));
}

public override void OnData(Slice slice)
{
    // Get Future chain
    if (!Portfolio.Invested && slice.FutureChains.TryGetValue(_future, out var chain))
    {
        if (chain.Count() &lt; 2) return;

        // Get the far and near contract
        var farContract = chain.MaxBy(x =&gt; x.Expiry);
        var nearContract = chain.MinBy(x =&gt; x.Expiry);

        // Check if the far contract price is 1% higher than the near one
        if (farContract.BidPrice &gt;= nearContract.AskPrice * 1.01m)
        {
            // If so, short the far contract and buy the near one to earn the premium
            MarketOrder(farContract.Symbol, -1);
            MarketOrder(nearContract.Symbol, 1);
        }
    }
}

public override void OnSecuritiesChanged(SecurityChanges changes)
{
    // Liquidate all positions if a contract expired and exit universe
    foreach (var removed in changes.RemovedSecurities)
    {
        Liquidate();
    }
}</pre>
    <pre class="python">def initialize(self) -&gt; None:
    # Add subscription of micro gold Futures
    future = self.add_future(Futures.Metals.MICRO_GOLD, extended_market_hours=True)
    self._future = future.symbol
    # Filter the universe to contracts expires within 3 months
    future.set_filter(lambda u: u.only_apply_filter_at_market_open().expiration(0, 95))

def on_data(self, slice: Slice) -&gt; None:
    # Get Future chain
    chain = slice.future_chains.get(self._future)
    if not self.portfolio.invested and chain:
        if len(list(chain)) &lt; 2:
            return

        # Get the far and near contract
        sorted_by_expiry = sorted(chain, key=lambda x: x.expiry)
        far_contract = sorted_by_expiry[-1]
        near_contract = sorted_by_expiry[0]

        # Check if the far contract price is 1% higher than the near one
        if far_contract.bid_price &gt;= near_contract.ask_price * 1.01:
            # If so, short the far contract and buy the near one to earn the premium
            self.market_order(far_contract.symbol, -1)
            self.market_order(near_contract.symbol, 1)

def on_securities_changed(self, changes: SecurityChanges) -&gt; None:
    # Liquidate all positions if a contract expired and exit universe
    for removed in changes.removed_securities:
        self.liquidate()</pre>
</div>